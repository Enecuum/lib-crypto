#define _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_DEPRECATE  

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include "crypto.h"

using namespace std;

class Point
{
	private:
		Point(BigNumber x, BigNumber y, EC_GROUP *curve) {
			this->P = EC_POINT_new(curve);
			if (1 != EC_POINT_set_affine_coordinates_GFp(curve, P, x.bn, y.bn, NULL)) return;
		}
		EC_POINT *P;
		friend class Curve;
		
};

std::string addSpaces(std::string str) {
	std::string tmp("");
	int len = str.size();
	if ((str.size() % 2) != 0) {
		str.insert(0, "0");
		len++;
	}
	for (int i = 2; i < str.size(); i += 3) {
		str.insert(i, " ");
	}
	return str;
}

int main(int argc, char ** argv)
{
	//OpenSSL_add_all_algorithms();
	//ERR_load_BIO_strings();
	//ERR_load_crypto_strings();

	//srand(time(0));
	//for (int i = 0; i < 1000; i++) {
	//	if ((i % 100) == 0) {
	//		std::cout.clear();
	//		cout << i << endl;
	//	}
	// std::cout.setstate(std::ios_base::failbit);
	//if (NULL == (ctx = BN_CTX_new())) handleErrors();

	//EC_GROUP *curve1;
	BigNumber a(1);
	BigNumber b(0);
	BigNumber p("80000000000000000000000000000000000200014000000000000000000000000000000000010000800000020000000000000000000000000000000000080003");

	BigNumber order("80000000000000000000000000000000000200014000000000000000000000000000000000010000800000020000000000000000000000000000000000080004");

	BigNumber g0x("2920f2e5b594160385863841d901a3c0a73ba4dca53a8df03dc61d31eb3afcb8c87feeaa3f8ff08f1cca6b5fec5d3f2a4976862cf3c83ebcc4b78ebe87b44177");
	BigNumber g0y("2c022abadb261d2e79cb693f59cdeeeb8a727086303285e5e629915e665f7aebcbf20b7632c824b56ed197f5642244f3721c41c9d2e2e4aca93e892538cd198a");

	BigNumber gx("2920f2e5b594160385863841d901a3c0a73ba4dca53a8df03dc61d31eb3afcb8c87feeaa3f8ff08f1cca6b5fec5d3f2a4976862cf3c83ebcc4b78ebe87b44177");
	BigNumber gy("2c022abadb261d2e79cb693f59cdeeeb8a727086303285e5e629915e665f7aebcbf20b7632c824b56ed197f5642244f3721c41c9d2e2e4aca93e892538cd198a");
	BigNumber max_hash("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

	//BigNumber gx = g0x;
	//BigNumber gy = g0y;
	cout << "a: " << a.toDecString() << endl;
	cout << "b: " << b.toDecString() << endl;
	cout << "p: " << p.toDecString() << endl;
	cout << "G0: (" << g0x.toDecString() << " " << g0y.toDecString() << ")" << endl;
	cout << "order: " << order.toDecString() << endl;
	Curve *curve = new Curve(a, b, p, order, g0x, g0y);
	//if (NULL == (curve1 = create_curve(a, b, p, order, g0x, g0y)))
	//	std::cout << "error" << endl;

	BigNumber msk(10000000);// = getRandom(BigNumber(1223));
	cout << "MSK: " << msk.toDecString() << endl;
	BigNumber q = order;	// G0 order


	//Curve cv(a, b, p, order, g0x, g0y);
	//EC_POINT *tst = cv.createPoint(gx, gy);
	//std::cout << "===============tst: ";
	//printPoint(tst, cv.getCurve());


	EC_POINT *G0 = EC_POINT_new(curve->curve);
	if (1 != EC_POINT_set_affine_coordinates_GFp(curve->curve, G0, g0x.bn, g0y.bn, NULL)) handleErrors();
	EC_POINT *G = EC_POINT_new(curve->curve);
	if (1 != EC_POINT_set_affine_coordinates_GFp(curve->curve, G, gx.bn, gy.bn, NULL)) handleErrors();

	std::cout << "G0: ";
	printPoint(G0, curve);
	EC_POINT *MPK = createMPK(msk, G0, curve);

	std::cout << "MPK: ";
	printPoint(MPK, curve);

	std::cout << "\r\n      PKG keys generation \r\n";

	// Вычисляем публичный ключ на этот сеанс
	// Второй генератор G (gens[1], 1158, 92)
	// Соучайный элемент из поля q = 13 (поля порядка gens[1])
	// TODO: set_random_seed(LPoSID + KblockID)
	int KblockID = 123;
	int LPoSID = 677321;
	// r следует брать соучайно r = ZZ.random_element(q)
	BigNumber r = getRandom(max_hash);
	std::cout << "Random r: " << r.toDecString() << endl;

	//BigNumber qx("11c258fa2953a595d24e3f3b5d9f54683bf3dfa16b9e4fc45eeccba2059ebe7b158077d7e2f12ed783e61f63f0d35b4dfcc95eac339f1760af690491a9621601");
	//BigNumber qy("6e737114083eacc07c8a5ce7e1ccfe769211b8aa59e6c3d94536d7ce2fbe41cae9cb19041211b6205a871cafa44a10a00a0e626d4bf7b3d4a874ea97b6ac1d6f");


	EC_POINT *Q = mul(r, G, curve);
	//EC_POINT *Q = EC_POINT_new(curve->curve);
	//if (1 != EC_POINT_set_affine_coordinates_GFp(curve->curve, Q, qx.bn, qy.bn, NULL)) handleErrors();


	std::cout << "Q = r * G: ";
	printPoint(Q, curve);
	/*
	std::cout << "Key sharing: " << endl;
	vector<int> ids = { 1, 55, 10 };
	vector<BigNumber> shares = shamir(msk, ids, 3, 2, q);
	for (int i = 0; i < shares.size(); i++)
		std::cout << "(" << shares[i].decimal() << "), ";

	vector<int> coalition = {1, 3 };
	std::cout << "\r\nShadows: " << "\r\n";
	vector<EC_POINT*> proj = keyProj(coalition, shares, Q, curve);
	for (int i = 0; i < proj.size(); i++) {
		printPoint(proj[i], curve);
	}
	vector<int> coalition2 = { 1, 10 };
	std::cout << "\r\n      Key recovery" << endl;
	EC_POINT *secret = keyRecovery(proj, coalition2, q, curve);

	std::cout << "Recovered secret SK: \t";
	printPoint(secret, curve);
	*/
	std::cout << "Check secret MSK * Q: \t";
	EC_POINT *check = mul(msk, Q, curve);
	printPoint(check, curve);

	std::cout << "\r\n      Create signature" << endl;
	
	BigNumber M(200);
	BigNumber r2 = getRandom(q);
	//cout << "r2: " << r2.toDecString() << endl;
	EC_POINT *s1;
	// R = rP
	s1 = mul(r2, G0, curve);

	//std::cout << "S1: ";
	//printPoint(s1, curve);
	/*
	verify_mobile(
		"16030569034403128277756688287498649515636838101184337499778392980116222246913",
		"0 0",
		"0 5",
		"16030569034403128277756688287498649515510226217719936227669524443298095169537",
		"12 1 7 16030569034403128277756688287498649515636838101184337499778392980116222246896 16030569034403128277756688287498649515636838101184337499778392980116222246710 16030569034403128277756688287498649515636838101184337499778392980116222246885 2309 2992 16030569034403128277756688287498649515636838101184337499778392980116222237244 16030569034403128277756688287498649515636838101184337499778392980116222225365 3429 48555 63122 37991",
		"13838462152992074156239747228301870532243102818506429855908557868826744084117",
		"606625360274408663760340386605740501472865973556987848848736775922772300329",
		12,
		"8676530956423454602758153543531960558859438025667737228646280652288345287180",
		"13711506478732940279682908474889299734255941719245266873309051652206327599441",
		"11 9478358642295234000188789130558698370825133847094552813221211279841128725525 6422313403487031312453636761909034150214125529213506141264364691060881808316 6847282238105727308159471518620961765324138381740026864472410302906064262932 1292561133607685064122325189982548458265486815892961627352476385955817092771 10362388751882803253542082533582704451533242604361589571568124587585448553238 13458559461125359525353644053363278148061376804059328713490810882830661386351 7833823548287634931844294538385345533296806851842100249818451714431430092904 4887546630958903230996309875711015939437896843000828561036624577277861720366 1874223639935192183886814365107187133672770695569017299687768237935928082317 7869345520044077403671918982065159940469629996013660533371861197895023545429 13250045081328286048926675309793152128272101193222685080682665609562986207148 10824607517870119006424737282838529766252483526983567677375539235567814875957",
		"11 3228155125977057539525873238211345878969014215102275914137003135105966683369 2405572606957177621809449144229032509080231769455790818772812865666265652796 13620950929085135356329607617871316360161095283693642504297576511336727526245 218152433820588656533816753473044801629157988462678539927014140549723481984 1830716749113836825770562359241402881531043371751112681913330032112513595763 1877617044793625488864905700530083652047949419766410569592826660624884946517 2231587641427745620156018443425187056100076211254531511187271913609343136389 5829335069257202239770668648658758038024380898804162881094635524763863445666 5904089016487722715819174940361371701012766566662413454933177900639477972052 6877232530224956759125291202244646138127232057703326689432664631144623706949 4086220486969736979342312417007714747897188355850704090652633816627697099742 2084620608346118675761440771456816745568835114677287622074682893247763181447",
		"56470459138520558769152534343598813777841594356566407190378029418004739181263",
		"103097942183933886863891626343267982122056901776108274454709365796960564732458",
		"4252101001885150195088325094083455701687363865997441267281044478965995472107",
		"3190996151686601768378566203618158287664895547489162477284637525319674443336",
		"b1100010011011010001011001001001100010110100010110001000000100010000100011101001010100101110111000010000100111101010111010010101010011000011100110001100100101010001100111010110110111100011001100101000101000101100011111100000010000010001110110111101101011001111000101001111101101000011101110110000100100010111010011111111111010000011011011100101101111001111010111000100111111010000110100101001001000011100000101010001010000000110001111111101001110101000101100001101100001110001011001010010111011101110010111100011001110100000011100100000001111110100011101000111001100000101101100110111011110001001110100110010000000111100110011010001010011010110011011011110010000011010011111010001010011111000010010100011000001010100000010110000001001001110011011101111000111110001011100110110000010001010101011010100111001101110011000110001011011110100101000001110100011001101110111110011110111011000111000110110010001101000010010001110100001011001111100010100010000111001010101101110111111010100110110000010011010111101001001110000000001101110011100000001100111100011000001110000010000111100010001110011001000011000100000000110001111100011111100101010010111011101110100000100111001000010110101000010010011000000110001111011011100111011111000000001101010011100110000000110110010011000111011001000111100100101111110101000000011010000110000110110100110010100010010101001001101010111110110110111111001011111100111011000011011101010101111011000000100111001110010010010111110010011110101101010101111110101001000111111100111010110011001010000010011000111110010110001111000010111100011011001001110000010010010010101101110000001001101101111010001110001011110101110001001011100110011111010001010110101011010000111011010110011111011101100001000001011110011100110011010000011010000111010100000101010110111001111010110010001111000101010010110010000100010000101100101011000110011011110101001011100010111100100101010011110100100001010010000001011111100110011100111110000110010111010110001001010101011011100100010010110110101010110111111010011000111110001010110110101101001011111100000010010000001110010110110001000111000000010001111100110011010110000100011110000110101001001100110000010111111110100100011100010101011010100110100011100010010000101110110010100100010001110010111000010101101011010011010110101110011010000110011100100110111000110000111000010001011110100001111011000010011111001000101100101101010111111101101111000000110010011110111111011101010100111110111001100001000001000000111000001011001011011101000110001001001010110110100100111111010101100011011111011010010000110101100011110110011001110110101110100001000010011000111111011011001000111010001101011101000110000111000101001101001110100001111101001001000101110000000000000000000000100011110111000000100100000000000000000000000000000000000000000000000"
	);
	return 0;
	*/

	Integer Ip, Im;
	Ip = Integer("6703903964971298549787012499102923063739684112761466562144343758833001675653841939454385015500446199477853424663597373826728056308768000892499915006541827");
	Im = Integer(2);
	string strIrred("2 1 1 6703903964971298549787012499102923063739684112761466562144343758833001675653841939454385015500446199477853424663597373826728056308768000892499915006541826");
	string strA("0 1");
	string strB("0 0");
	string strG0_x("1 1971424652593645857677685913504949042673180456464917721388355467732670356866868453718540344482523620218083146279366045128738893020712321933640175997249379 4296897641464992034676854814757495000621938623767876348735377415270791885507945430568382535788680955541452197460367952645174915991662132695572019313583345");
	string strG0_y("1 5439973223440119070103328012315186243431766339870489830477397472399815594412903491893756952248783128391927052429939035290789135974932506387114453095089572 3254491657578196534138971223937186183707778225921454196686815561535427648524577315556854258504535233566592842007776061702323300678216177012235337721726634");
	ellipticCurve *ec = new ellipticCurve(Ip, Im, strIrred, strA, strB);
	//ec->print();
	ellipticCurveFq E_Fq(ec);

	
	ExtensionField::Element HFq_x, HFq_y, SFq_x, SFq_y, G0_x, G0_y;

	E_Fq.field->readElement(strG0_x, G0_x);
	E_Fq.field->readElement(strG0_y, G0_y);
	ecPoint G0_fq(G0_x, G0_y);
	ecPoint MPK_fq;
	E_Fq.scalarMultiply(MPK_fq, G0_fq, (Integer)(msk.toDecString()), -1);

	ecPoint secret_fq = mapToFq(check, curve, E_Fq);

	/*
	BigNumber hash("c8411fd7002be15c6d266bdf516fbd49ef101e0e6454c4fcac0a0736e7ad15aa");
	ecPoint eee = hashToPointFq(secret_fq, hash, E_Fq);
	cout << "\n eee " << endl;
	E_Fq.show(eee);
		return 0;
*/


	//cout << "\n secret fq: " << endl;
	//E_Fq.show(secret_fq);
	BigNumber hash = getRandom(max_hash);
	cout << "\n hash: " << hash.toDecString() << endl;
	//string strHx_fq("1 6585938874884161190249790176567180373159829994480512034157897828690094321702398082583836641936540925052205593236857739108779400699876416733619250033001574 1114870903498799919300311051614230487702143776715306484413118861977974710144846490697848621314514171343204111400320074712855582002282753809846905090592511");
	//string strHy_fq("1 5977369586974353026773600315229776563237092478572059568886286293271512008099964983767401181053880836241479041663079843436368298305692856067127602342710521 2161202195522849472617767678421059087248221940509956469640162759356556534804221688741829365093541793519766900881300788512903369980421169424075071068242390");
	//E_Fq.field->readElement(strHx_fq, HFq_x);
	//E_Fq.field->readElement(strHy_fq, HFq_y);

	//BigNumber yy = hashToPoint(hash);
	//std::cout << std::endl << "yy: " << yy.toDecString() << std::endl;
	//EC_POINT *H = EC_POINT_new(curve->curve);
	//if (1 != EC_POINT_set_affine_coordinates_GFp(curve->curve, H, hash.bn, yy.bn, NULL)) handleErrors();
	
	
	ecPoint H_fq = hashToPoint(hash);//hashToPointFq(secret_fq, hash, E_Fq);
	cout << "\n H_fq: " << endl;
	E_Fq.show(H_fq);
	ecPoint rH, S2_fq;
	
	E_Fq.scalarMultiply(rH, H_fq, (Integer)(r2.toDecString()), -1);//R=6*P, order of P is not required
	//cout << "\n rH: " << endl;
	//E_Fq.show(rH);

	E_Fq.add(S2_fq,rH, secret_fq);//R=P+Q
	cout << "\n S2_fq: " << endl;
	E_Fq.show(S2_fq);

	BigNumber shash = getRandom(q);
	//string strSx_fq("1 6159497620935257906557343540898005704075905690051056620736859984179681011970149193326830486125500760419791791564998991498449345753926314997987382523405921 3955639758400305255197132500245584107122348438917038996230137507748635098851063891808983517470373013192290448706270855321350612334250594749922405365544392");
	//string strSy_fq("1 1358517738138214687498297006528551934170768973346051715607110811974480465953218306945989515494073925868991969272612769952234634613804574004024545343325167 617848479534351383674347258603898500438322921182801022785593855537092883000984751823642698365488639632813733693500782440637339604880634710794074753004823");
	//E_Fq.field->readElement(strSx_fq, SFq_x);
	//E_Fq.field->readElement(strSy_fq, SFq_y);
	ecPoint S_fq = hashToPointFq(secret_fq, shash, E_Fq);
	cout << "\n S_fq: " << endl;
	E_Fq.show(S_fq);

	//ecPoint G0_fq = mapToFq(G, curve, E_Fq);
	//ecPoint MPK_fq = mapToFq(MPK, curve, E_Fq);
	ecPoint S1_fq;
	E_Fq.scalarMultiply(S1_fq, G0_fq, (Integer)(r2.toDecString()), -1);//R=6*P, order of P is not required
	cout << "\n S1_fq: " << endl;
	E_Fq.show(S1_fq);
	//mapToFq(s1, curve, E_Fq);

	//cout << "\n G0_fq: " << endl;
	//E_Fq.show(G0_fq);

	ecPoint Q_Fq = mapToFq(Q, curve, E_Fq);
	//E_Fq.scalarMultiply(Q_Fq, G0_fq, (Integer)(msk.toDecString()), -1);
	//cout << "\n Q_Fq: " << endl;
	//E_Fq.show(Q_Fq);
	//std::stringstream ss;
	//E_Fq.field->writeElement(r1, ss);

	//cout << ss.str() << endl;
	//vector<string> elements;
	//string temp;
	//while (!ss.eof()) {
	//	ss >> temp;
	//	if (temp == "+")
	//		continue;
	//	std::size_t start = temp.find("(");
	//	std::size_t end = temp.find(")");
	//	std::string str3 = temp.substr(start + 1, end - 1);
	//	elements.push_back(str3);
	//	//cout << str3 << endl;
	//	temp = "";
	//}
	ExtensionField::Element rr, bb, cc;
	rr = tatePairing(S2_fq, G0_fq, S_fq, E_Fq);
	bb = tatePairing(Q_Fq, MPK_fq, S_fq, E_Fq);
	cc = tatePairing(H_fq, S1_fq, S_fq, E_Fq);
	//return 0;
	// TODO: cacl instead of hard-code
	string strEta = "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000100000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000010";
	BigNumber bnEta("80000000000000000000000000000000000200014000000000000000000000000000000000010000800000020000000000000000000000000000000000080002");
	
	/*
	  eta = (p^k - 1)/q
	  tate pairing return value should be in `eta` degree
	  num = eval_miller(P, Q+S)/eval_miller(P,  S)
	  return (num^eta)
	*/
	ExtensionField::Element r1, b1, c1, b1c1;
	E_Fq.field->pow(r1, rr, strEta);
	E_Fq.field->pow(b1, bb, strEta);
	E_Fq.field->pow(c1, cc, strEta);

	ExtensionField::Element bbcc;
	E_Fq.field->mul(b1c1, b1, c1);

	//E_Fq.field->pow(b1c1, bbcc, strEta);
	cout << "\n r1: " << endl;
	E_Fq.field->writeElement(r1);
	cout << "\n b1: " << endl;
	E_Fq.field->writeElement(b1);
	cout << "\n c1: " << endl;
	E_Fq.field->writeElement(c1);
	cout << "\n b1c1: " << endl;
	E_Fq.field->writeElement(b1c1);
	cout << "\n Verified: " << E_Fq.field->areEqual(r1, b1c1) << endl;
	/**/
	//int verify = (r1 == b1c1)
	//cout << "\n Verified: " << verify << endl;
	cout << "\r\nruntime is: " << clock() / 1000.0 << endl; // время работы программы  

	//ExtensionField::Element rand;
	//E_Fq.field->random(rand);
	//cout << "\n rand: " << endl;
	//E_Fq.field->writeElement(rand);
	EC_POINT_free(Q);
	EC_POINT_free(MPK);
	EC_POINT_free(G);
	EC_POINT_free(G0);
	EC_POINT_free(check);
	EC_POINT_free(s1);
	delete(curve);
	return 0;
}